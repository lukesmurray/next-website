---
title: "React Query Auto Sync Hook"
date: "2021-07-26T09:25:28"
description: "How to build an auto sync hook with react query"
draft: false
# image: /path/to/image
---

In this post I'll show you how to build an auto sync hook with react query.
The hook is useful for building user interfaces which auto save.
Auto save interfaces are useful for [preventing accidental data loss](http://ui-patterns.com/patterns/autosave) and have become the [norm in document based applications](https://developer.apple.com/design/human-interface-guidelines/macos/system-capabilities/auto-save/).
Despite the increasing prevalance of auto save interfaces, I found very little information about how to build one with react query.
Most of the examples in react query either expect the user to manually send data to the server using a _create_ or _save_ button, or [provide separate interfaces](https://react-query.tanstack.com/examples/playground) for viewing data from the server and editing it locally.

As a general rule, when using react query you should [keep server and client state separate](https://tkdodo.eu/blog/practical-react-query#keep-server-and-client-state-separate).
Server state is the `data` returned by a [`useQuery`](https://react-query.tanstack.com/reference/useQuery) call.
Client state is locally modified server state.
When you want to modify server state with react query, you make a copy of the server state and modify the copy.

<Admonition type="Note" title="Why">

ReactQuery assumes that the `data` object only changes based on updates from the server uses _structural sharing_ (a deep comparison of the object's values) to memoize the query results.
Changing the `data` object directly breaks a lot of the assumptions ReactQuery uses to handle caching, updating, and memoizing query results.

</Admonition>

<!--  -->

Here is an example hook that can be used to implement a separation of server and client state while maintaining a simple external API.

```tsx
import { useState } from "react";
import { QueryKey, useQuery, UseQueryOptions } from "react-query";

export function useReactQueryAutoSync<
  TQueryFnData = unknown,
  TQueryError = unknown,
  TQueryData = TQueryFnData,
  TQueryKey extends QueryKey = QueryKey
>({
  queryOptions,
}: {
  queryOptions: UseQueryOptions<
    TQueryFnData,
    TQueryError,
    TQueryData,
    TQueryKey
  >;
}) {
  const [draft, setDraft] = useState<TQueryData | undefined>(undefined);

  const queryResult = useQuery(queryOptions);

  return {
    setDraft,
    draft: draft ?? queryResult.data,
    queryResult,
  };
}
```

The consumer of this hook does not have to think about the separation of server and client state.
They can simply use the `draft` value directly as long as they only modify the draft value using `setDraft`.

However modifying server state isn't very useful unless we have a way to save that state back to the server.
We'll start by adding a manual `save` function to the hook.
In order to save however we'll also need to provide mutation options to the hook and return a mutation result.

```tsx
import { useCallback, useRef, useState } from "react";
import {
  QueryKey,
  useMutation,
  UseMutationOptions,
  useQuery,
  UseQueryOptions,
} from "react-query";

export function useReactQueryAutoSync<
  /*...*/
  TMutationData = unknown,
  TMutationError = unknown,
  TMutationContext = unknown
>({
  queryOptions,
  mutationOptions,
}: {
  queryOptions: /*...*/
  mutationOptions: UseMutationOptions<
    TMutationData,
    TMutationError,
    TQueryData, // input to mutate is the same as the output of the query
    TMutationContext
  >;
}) {
  const [draft, setDraft] = useState<TQueryData | undefined>(undefined);

  // create a stable ref to the draft so we can memoize the save function
  const draftRef = useRef<TQueryData | undefined>(undefined);
  draftRef.current = draft;

  const queryResult = useQuery(queryOptions);

  // we provide options to useMutation that optimistically update our state
  const mutationResult = useMutation(mutationOptions);

  const { mutate } = mutationResult;

  // return a stable save function
  const save = useCallback(() => {
    if (draftRef.current !== undefined) {
      mutate(draftRef.current);
    }
  }, [mutate]);

  return {
    save,
    setDraft,
    /*...*/
    mutationResult,
  };
}
```

The consumer of this hook can now use the `save` function to save the current draft to the server.

To make this concrete here is an example of how to use the hook in its current state.

```tsx
import React from "react";
import { useReactQueryAutoSync } from "./useReactQueryAutoSync";

function HookDemo() {
  const { draft, setDraft, save } = useReactQueryAutoSync(
    {
      queryKey: "foo",
      queryFn: () => {
        /* omitted */
      },
    },
    {
      mutationFn: async () => {
        /* omitted */
      },
    }
  );
  return (
    <>
      <input
        type="text"
        value={draft}
        onChange={(e) => setDraft(e.target.value)}
      />
      <button onClick={() => save()}>Save</button>
    </>
  );
}
```

We treat the `draft` and `setDraft` values similarly to the result of a `useState` and when we want to save the `draft` value to the server we call `save`.

Before we go on I have to admit that the previous hook omitted some important implementation details from `useMutation`.
Whenever we perform an implementation we want to use [optimistic updates](https://react-query.tanstack.com/guides/optimistic-updates) so that the user does not have to wait for the `draft` to save to the server before they can continue working.
We want to assume the save function succeeded but rollback if the save function fails.

```ts
export function useReactQueryAutoSync</*...*/>({}: /*...*/
{
  /*...*/
}) {
  /*...*/

  const queryClient = useQueryClient();
  const queryKey = queryOptions.queryKey!;

  // we provide options to useMutation that optimistically update our state
  const mutationResult = useMutation({
    ...mutationOptions,
    onMutate: async (draft) => {
      // Cancel any outgoing refetches (so they don't overwrite our optimistic update)
      await queryClient.cancelQueries(queryKey);
      // Snapshot the last known server data
      const previousData = queryClient.getQueryData(queryKey);
      // optimistically set our known server state to the new data
      queryClient.setQueryData(queryKey, draft);
      // optimistically clear our draft state
      setDraft(undefined);
      // Return a context object with the snapshotted value
      return {
        previousData,
        ...mutationOptions.onMutate?.(draft),
      } as any;
    },
    onError: (err, draft, context) => {
      // reset the server state to the last known state
      queryClient.setQueryData(queryKey, (context as any).previousData);
      // reset the draft to the last known draft unless the user made more changes
      if (draft !== undefined) {
        setDraft(draft as any);
      }
      return mutationOptions.onError?.(err, draft, context);
    },
    onSettled: (data, error, variables, context) => {
      // refetch after error or success:
      queryClient.invalidateQueries(queryKey);
      return mutationOptions?.onSettled?.(data, error, variables, context);
    },
  });

  /*...*/

  return {
    /*...*/
  };
}
```

These changes look complicated but if you check out the [optimistic updates](https://react-query.tanstack.com/guides/optimistic-updates) guide you'll see that they are essentially boilerplate.
The only additional change is that we maintain our `draft` state in the optimistic updates as well as the reactQuery data.

As a nice side effect we can assume that if the `draft` value is undefined then local changes have been saved to the server.
If you look at our `save` function you can see that we use this guarantee to avoid sending unecessary data to the server.

```ts
const save = useCallback(() => {
  if (draftRef.current !== undefined) {
    mutate(draftRef.current);
  }
}, [mutate]);
```

Now that we have a way to manually save the `draft` to the server we can implement an auto save interface.
Auto save interfaces are often used for documents which tend to change frequently and can be relatively large.
We don't want to clobber the server with changes and save on every keystroke so we'll use a debounce function to only save after a certain amount of time has passed between changes.

```ts
import debounce from "lodash.debounce";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  QueryKey,
  useMutation,
  UseMutationOptions,
  useQuery,
  UseQueryOptions,
} from "react-query";

/**
 * Empty function used to avoid the overhead of `lodash.debounce` if autoSaveOptions are not used.
 */
const EmptyDebounceFunc = Object.assign(() => {}, {
  flush: () => {},
  cancel: () => {},
});

export interface AutoSaveOptions {
  wait: number;
  maxWait?: number;
}

export function useReactQueryAutoSync</*...*/>({
  /*...*/
  autoSaveOptions,
}: {
  /*...*/
  autoSaveOptions?: AutoSaveOptions;
}) {
  /*...*/

  // return a stable save function
  const save = useCallback(() => {
    if (draftRef.current !== undefined) {
      mutate(draftRef.current);
    }
  }, [mutate]);

  // memoize a debounced save function
  const saveDebounced = useMemo(
    () =>
      autoSaveOptions?.wait === undefined
        ? EmptyDebounceFunc
        : debounce(save, autoSaveOptions?.wait, {
            // only pass maxWait to the options if maxWait is defined
            // if maxWait is undefined it is set to 0
            ...(autoSaveOptions?.maxWait !== undefined
              ? { maxWait: autoSaveOptions?.maxWait }
              : {}),
          }),
    [autoSaveOptions?.maxWait, autoSaveOptions?.wait, save]
  );

  // clean up saveDebounced on unmount to avoid leaks
  useEffect(() => {
    const prevSaveDebounced = saveDebounced;
    return () => {
      prevSaveDebounced.cancel();
    };
  }, [saveDebounced]);

  // call saveDebounced when the draft changes
  useEffect(() => {
    // check that autoSave is enabled and there are local changes to save
    if (autoSaveOptions?.wait !== undefined && draft !== undefined) {
      saveDebounced();
    }
  }, [saveDebounced, draft, autoSaveOptions?.wait]);

  // create a function which saves and cancels the debounced save
  const saveAndCancelDebounced = useMemo(
    () => () => {
      saveDebounced.cancel();
      save();
    },
    [save, saveDebounced]
  );

  return {
    save: saveAndCancelDebounced,
    setDraft,
    draft: draft ?? queryResult.data,
    queryResult,
    mutationResult,
  };
}
```

We provide an `autoSaveOptions` parameter which is use to set the delay and max delay for our debounce[^lodashdebounce].
We then use these parameters to create a debounced version of our `save` function [^usememoperformance].
If the user does not provide an `autoSaveOptions` parameter we use the `EmptyDebounceFunc` which is a no-op function that replicates the `[lodash.debounce](https://lodash.com/docs/4.17.15#debounce)` api.
We make sure to clean up our debounce function when the component unmounts to avoid memory leaks.
Most importantly we call `saveDebounced` when the `draft` value changes.

[^lodashdebounce]: See [`lodash.debounce`](https://lodash.com/docs/4.17.15#debounce) for documentation on these parameters.
[^usememoperformance]: We could have used `useCallback` here but then we would call `lodash.debounce` on every render. `useMemo` is more performant and only calls `lodash.debounce` when one of the dependencies. Check out [Kent C. Dodd's article](https://kentcdodds.com/blog/usememo-and-usecallback/) comparing `useMemo` and `useCallback` if you're interested in learning more about this.

You may have noticed that we created a `draftRef` so that the `save` function does not have to list `draft` as one of its dependencies.
This is important because otherwise the debounced save function would have to be recreated whenver the `draft` value changes which is both expensive and breaks debounce functionality such as `maxDelay`.

When the user manually saves the draft value with `save` we cancel the debounced save function to avoid double saves.

At this point the hook is already useful for creating auto save interfaces.
However there are a couple of user experience issue we can still address.
For example we may want to prevent the user from leaving the page if the hook has outstanding local changes.

```ts
/*...*/

export function useReactQueryAutoSync</*...*/>({
  /*...*/
  alertIfUnsavedChanges,
}: {
  /*...*/
  alertIfUnsavedChanges?: boolean;
}) {
  /*...*/

  // create a function which saves and cancels the debounced save
  const saveAndCancelDebounced =
    useMemo();
    /*...*/

  // confirm before the user leaves if the draft value isn't saved
  useEffect(() => {
    const shouldPreventUserFromLeaving =
      draft !== undefined && alertIfUnsavedChanges;

    const alertUserIfDraftIsUnsaved = (e: BeforeUnloadEvent) => {
      if (shouldPreventUserFromLeaving) {
        // Cancel the event
        e.preventDefault(); // If you prevent default behavior in Mozilla Firefox prompt will always be shown
        // Chrome requires returnValue to be set
        e.returnValue = "";
      } else {
        // the absence of a returnValue property on the event will guarantee the browser unload happens
        delete e["returnValue"];
      }
    };

    // only add beforeUnload if there is unsaved work to avoid performance penalty
    if (shouldPreventUserFromLeaving) {
      window.addEventListener("beforeunload", alertUserIfDraftIsUnsaved);
    }
    // document.addEventListener("visibilitychange", saveDraftOnVisibilityChange);
    return () => {
      if (shouldPreventUserFromLeaving) {
        window.removeEventListener("beforeunload", alertUserIfDraftIsUnsaved);
      }
      // document.removeEventListener("visibilitychange", saveDraftOnVisibilityChange);
    };
  }, [alertIfUnsavedChanges, draft, saveAndCancelDebounced]);

  return {
    /*...*/
  };
}
```

We use the `beforeUnload` event to warn the user if they are leaving the page with unsaved changes[^beforeunloadbestpractices].

[^beforeunloadbestpractices]: Note that [best practices](https://web.dev/bfcache/) recommend that you only add a `beforeUnload` event listener when the user has unsaved changes. Our hook follows these practices by only adding the event listener when the user has unsaved changes and properly cleaning up the event listener in `useEffect`.

For one last step let's see if we can handle merging changes from the server with the outstanding local changes to the draft.
We can do this by passing a merge function and merging the server and local state if they are both defined.

```tsx
export type MergeFunc<TQueryData> = (
  remote: TQueryData,
  local: TQueryData
) => TQueryData;

export function useReactQueryAutoSync</*...*/>({
  /*...*/
  merge,
}: {
  /*...*/
  merge?: MergeFunc<TQueryData>;
}) {
  /*...*/

  // merge the local data with the server data when the server data changes
  useEffect(() => {
    const serverData = queryResult.data;
    if (serverData !== undefined && merge !== undefined) {
      setDraft((localData) => {
        if (localData !== undefined) {
          return merge(serverData, localData);
        }
      });
    }
  }, [merge, queryResult.data]);

  return {
    /*...*/
  };
}
```

<Admonition type="note" title="Concurrent Editing">

Concurrent editing is outside the scope of this post.
The merge function described here might not support concurrent editing from multiple users.
If you are interested in more robust solutions for collaborative editing you could check out CRDT implementations such as [yjs](https://github.com/yjs/yjs) or [Automerge](https://github.com/automerge/automerge) or realtime collaboration APIs such as [replicache](https://replicache.dev/)

</Admonition>

<!--  -->

This hook can be used to automatially synchronize a value with a server.
Later on I may share a code sandbox which uses this hook in a more interesting scenario, compare the usage of this hook to other alternatives for synchronizing state such as websockets, long polling, and [replicache](https://replicache.dev/), and answer when using this type of synchronization is a good idea and when other alternatives are better. For now the [code for this hook](https://github.com/lukesmurray/react-query-autosync) can be found on github with some minor changes.
